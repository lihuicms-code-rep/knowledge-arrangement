第六章:树
1.树的定义
  Tree是具有n(n>=0)个结点的有限集,n=0时称为空树.
  在任意一个非空树中,具有如下特征
  1)尤其仅有一个特定的称为根(Root)的结点
  2)当n>1时,其余结点可以分为m(m>0)个互不相交的有限集T1,T2,T3....Tm,其中的每一个集合又是一颗树,称为根的子树subTree
  在树的定义之中还用到了树的概念,这其实就是递归的体现。

  关于定义后的注意事项
  1.n>0时,根结点是唯一的
  2.m>0时,子树的个数是没有限制的,但他们一定是不相交

2.相关概念需要理解清楚
  1.结点分类
    结点拥有的子树称为结点的度,可以根据结点的度来对树中的结点进行分类
    1)根结点
    2)叶节点:度为0的结点
    3)非终端结点或者分支结点
    树的度是树内各结点的度的最大值.
  2.结点间关系
    孩子child, 双亲parent, 兄弟sibling, 子孙
  3.结点层次
    从根开始是第一层,树中结点的最大层次称为树的深度(高度)
    树中结点各个子树从左到右是有次序的，不能互换的,称为有序树，否则是无序树
3.树的抽象数据类型
  ADT 树
  Data
     树是由一个根结点和若干棵子树构成,树中的结点有相同数据类型，有层次关系
  Operation
     等具体实现的时候逐一列出来
  endADT

4.树的存储结构
  1.双亲表示法
    除了根结点以外,其余每个结点,可能没有孩子，但一定有且仅有一个双亲.
    特殊的,根结点没有双亲,其parent为-1
    type Node struct {
        data byte     //数据域
        parent int    //其双亲结点下标
    }

    type Tree struct {
        nodes [max]Node  //存储数组
        root int         //根结点下标
        num int          //当前结点数
    }
  2.孩子表示法
    孩子表示法的演变有一个过程,这个过程中考虑加上不同的字段或者添加什么样的字段能达到什么影响
    考虑一个问题,树中每个结点的度是不一样的,那么每个结点的孩子个数就是不一样的
    1)直接用树的度作为每个结点的度
    const treeDegree = xxx
    type Node struct {
        data byte        //数据域
        children [treeDegree]*Node    //指向孩子结点的指针数组
    }

    type Tree struct {
        nodes [max]Node   //存储数组
        root  int         //根结点下标
        num   int         //当前结点数
    }

    好处是能统一指针数组长度,坏处是比如度比较少的结点,浪费空间

    2)能确定每个结点的度
    type Node struct {
        data byte        //数据域
        degree int       //结点度
        children []*Node //指针数组
    }

    type Tree struct {
        nodes [max]Node   //存储数组
        root  int         //根结点下标
        num   int         //当前结点数
    }

    好处是每个结点的都能恰好表示到,不好的一点是指针数据长度不一,不方便

    3)最终版，就是每个结点的孩子结点链成链表
    type Node struct {
        data byte         //数据域
        children *
    }

    type LinkNode struct {
        index int         //在数组中的下标
        next *LinkNode    //其双亲结点的下一个孩子结点
    }

    type Tree struct {
        nodes [max]Node   //存储数组
        root  int         //根结点下标
        num   int         //当前结点数
    }

  3.孩子兄弟表示法,这种表示法将一颗很复杂的树只用两个指针域就能描述
    其核心思想就是记录改结点的第一个孩子结点(最左边)和其右边第一个兄弟
    type Node struct {
        data byte         //数据域
        firstChild *Node  //第一个孩子结点
        rightSibling *Node  //右兄弟结点
    }

    type Tree struct {
        nodes [max]Node   //存储数组
        root  int         //根结点下标
        num   int         //当前结点数
    }

5.二叉树
  1.定义
    二叉树(Binary Tree)是n(n>=0)个结点的有限集合,该集合或者为空集(空二叉树),或者由一个根结点
    和两棵互不相交的分别称为左子树和右子树的二叉树组成。
  2.特点
    1)每个结点最多只有两棵子树,所以二叉树中不存在度大于2的结点
    2)左子树和右子树是有顺序的,次序不可以颠倒(类比左右手)
    3)即使树中某结点只有一颗子树,也要区分是左子树还是右子树

  3.二叉树形态
    思考，3个结点的二叉树可能有多少种形态
  4.特殊二叉树
    1)斜树(左斜树,右斜树)
    2)满二叉树
      定义:所有分支结点都有左子树和右子树,并且所有的叶子都在同一层上
      特征:
      1.叶子只能出现在最下面一层,在其他层出现就不能平衡
      2.非叶子结点的度一定是2
      3.在同等深度的二叉树中,满二叉树的结点个数最多
    3)完全二叉树
      一棵具有n个结点的二叉树按层序编号(重要),如果编号为i(1<=i<=n)的结点与同样深度的满二叉树的
      编号为i的结点在二叉树中位置完全相同,则称为完全二叉树。(编号发现空挡,就不是完全二叉树)
      特征:同样结点数的二叉树,完全二叉树的深度最小
  5.二叉树性质
    1)在二叉树的第i层至多只有2^(i-1)个结点(i>=1)
    2)深度为K的二叉树至多只有2^k - 1个结点(k>=1)
    3)证明n0 = n2 +1
      有n个结点的二叉树
      n = n2 + n1 + n0  (n2:度为2的结点个数,n1:度为1的结点个数,n0:度为0的结点个数)
      而n个结点一共有n-1条边,度为2的结点会伸出2条
      n - 1 = 2 * n2 + 1 * n1 + 0 * n0
      两式合并
      n0 = n2 + 1

    4)具有n个结点的完全二叉树深度为[log2N]+1
    5)第五个性质在实际应用时再说

  6.二叉树的存储
    二叉链表
  7.二叉树的遍历
    1)定义:从根结点出发,按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且只被访问一次
    2)关键点:访问和次序
    3)遍历方式:
      前序遍历:若二叉树为空,则空操作返回,否则先访问根结点,然后前序遍历左子树,再前序遍历右子树(注意,定义的时候用定义)
      中序遍历,
      后序遍历,
      层次遍历
      对于计算机来说就是将这些结点变成某种意义的线性顺序
      看一下各个遍历方式用代码实现后如何理解这个过程
    4)二叉树建立时,需要一个扩展二叉树
      这个还没怎么明白
    5)线索二叉树
















