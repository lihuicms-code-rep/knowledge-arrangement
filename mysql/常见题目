一.索引
  1.什么是索引
    索引是对数据库中一或多个列值的排序，帮助数据库高效获取数据的数据结构
  2.基本的索引类型
    1)普通索引
      CREATE INDEX indexName ON mytable(username(length));
    2)唯一索引
      它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一
      CREATE UNIQUE INDEX indexName ON mytable(username(length))
    3)主键索引
      它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引
      CREATE TABLE mytable(
      ID INT NOT NULL,
      username VARCHAR(16) NOT NULL,
      PRIMARY KEY(ID)
      )
    4)组合索引
      有表结构如下:
      CREATE TABLE mytable(  
      ID INT NOT NULL,   
      username VARCHAR(16) NOT NULL,  
      city VARCHAR(50) NOT NULL,  
      age INT NOT NULL 
      );  

      //创建组合索引
      ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);
      //理解下面的情况,最左前缀

      建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：
      usernname,city,age  
      usernname,city  
      usernname  
      为什么没有 city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：

      SELECT * FROM mytable WHREE username="admin" AND city="郑州" 
      SELECT * FROM mytable WHREE username="admin" 

      而下面几个则不会用到：
      SELECT * FROM mytable WHREE age=20 AND city="郑州" 
      SELECT * FROM mytable WHREE city="郑州" 

    5)建立索引的时机
      一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE才会使用索引
    6)索引的不足之处
      ◆虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。
      ◆建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
      索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。
    7)索引的原理
      1)数据结构(B-Tree和B+Tree)
      想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是b tree或者 b+ tree，
      重要的事情说三遍：“平衡树，平衡树，平衡树”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ，
      然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。

      2)聚集索引
      这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。
      然而， 事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的，
      因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构，
      因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。

      3)非聚集索引
        非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。
        索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，
        在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，
        每个索引（非聚集索引）互相之间不存在关联
二.事务
   事务(Transaction)是并发控制的基本单位。事务就是一系列的操作，这些操作要么都执行，要么都不执行。
   1.特性(ACID)
   1)原子性(Atomicity)
     原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响
   2)一致性(Consistency)
      一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
      拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
   3)隔离性(Isolation)
     隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
     即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
   4)持久性
     持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
     例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，
     即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误

   2.事务语句
     · 开始事物：BEGIN TRANSACTION

     · 提交事物：COMMIT TRANSACTION

     · 回滚事务：ROLLBACK TRANSACTION
   3.事务的隔离级别
     数据库的事务无非就是两种:读取事务,修改事务
     在没有事务隔离控制的情况下,会发生以下一些情况
     （1） 两个更新事务同时修改一条数据时，很显然这种情况是最严重的了，程序中无论如何也不能出现这种情况，因为它会造成更新的丢失！
     （2） 一个更新事务更新一条数据时，另一个读取事务读取了还没提交的更新(还未完全成功的事务)，这种情况下会出现读取到脏数据。
     （3） 一个读取事务读取一条数据时，另一个更新事务修改了这条数据，这时就会出现不可重现的读取。
     （4）一个读取事务读取时，另一个插入事务（注意此处时插入）插入了一条新数据，这样就可能多读出一条数据，出现幻读。
     以上四种情况描述完毕，相信大家也发现规律了，前三种是对同一条数据的并发操作，对程序的结果可能产生致命影响，尤其是金融等实时性，准确性要求极高的系统，绝不容许这三中情况的出现，
     相比第四种情况不会影响数据的真实性，在很多情况下是允许的，如社交论坛等实时性要求不高的系统！
     综上四个情况，我们可以大致这样简单的理解（最初说的两种事务的自由组合2*2=4）：
     A） 修改时允许修改（丢失更新）
     B） 修改时允许读取（脏读）,入银行转账
     C) 读取时允许修改（不可重复读）
     D) 读取时允许插入（幻读）
三.MySQL存储引擎的区别
   1)InnoDB支持事务，MyISAM不支持。
   2)MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用。
   3)InnoDB支持外键，MyISAM不支持。
   4)从MySQL5.5.5以后，InnoDB是默认引擎。
   5)MyISAM支持全文类型索引，而InnoDB不支持全文索引。
   6)InnoDB中不保存表的总行数，select count(*) from table时，InnoDB需要扫描整个表计算有多少行，但MyISAM只需简单读出保存好的总行数即可。注：当count(*)语句包含where条件时MyISAM也需扫描整个表。
   7)对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。
   8)清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。MyisAM使用delete语句删除后并不会立刻清理磁盘空间，需要定时清理，命令：OPTIMIZE table dept;
   9)InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’）
   10)Myisam创建表生成三个文件：.frm 数据表结构 、 .myd 数据文件 、 .myi 索引文件，Innodb只生成一个 .frm文件，数据存放在ibdata1.log
   11)现在一般都选用InnoDB，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。
   应用场景：
   MyISAM不支持事务处理等高级功能，但它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
   InnoDB用于需要事务处理的应用程序，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能
四.Mysql的锁机制
